/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

///////////////////////////////////////////////////////////////////////////////
// Description: SPI (Serial Peripheral Interface) Master
//              Creates master based on input configuration.
//              Sends a byte one bit at a time on MOSI
//              Will also receive byte data one bit at a time on MISO.
//              Any data on input byte will be shipped out on MOSI.
//
//              To kick-off transaction, user must pulse i_TX_DV.
//              This module supports multi-byte transmissions by pulsing
//              i_TX_DV and loading up i_TX_Byte when o_TX_Ready is high.
//
//              This module is only responsible for controlling Clk, MOSI, 
//              and MISO.  If the SPI peripheral requires a chip-select, 
//              this must be done at a higher level.
//
// Note:        i_Clk must be at least 2x faster than i_SPI_Clk
//
// Parameters:  SPI_MODE, can be 0, 1, 2, or 3.  See above.
//              Can be configured in one of 4 modes:
//              Mode | Clock Polarity (CPOL/CKP) | Clock Phase (CPHA)
//               0   |             0             |        0
//               1   |             0             |        1
//               2   |             1             |        0
//               3   |             1             |        1
//              More: https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Mode_numbers
//              CLKS_PER_HALF_BIT - Sets frequency of o_SPI_Clk.  o_SPI_Clk is
//              derived from i_Clk.  Set to integer number of clocks for each
//              half-bit of SPI data.  E.g. 100 MHz i_Clk, CLKS_PER_HALF_BIT = 2
//              would create o_SPI_CLK of 25 MHz.  Must be >= 2
//
///////////////////////////////////////////////////////////////////////////////

module SPI_Master
  #(parameter SPI_MODE = 0,
    parameter CLKS_PER_HALF_BIT = 2)
  (
   // Control/Data Signals,
   input        i_Rst_L,     // FPGA Reset
   input        i_Clk,       // FPGA Clock
   
   // TX (MOSI) Signals
   input [7:0]  i_TX_Byte,        // Byte to transmit on MOSI
   input        i_TX_DV,          // Data Valid Pulse with i_TX_Byte
   output reg   o_TX_Ready,       // Transmit Ready for next byte
   
   // RX (MISO) Signals
   output reg       o_RX_DV,     // Data Valid pulse (1 clock cycle)
   output reg [7:0] o_RX_Byte,   // Byte received on MISO

   // SPI Interface
   output reg o_SPI_Clk,
   input      i_SPI_MISO,
   output reg o_SPI_MOSI
   );

  // SPI Interface (All Runs at SPI Clock Domain)
  wire w_CPOL;     // Clock polarity
  wire w_CPHA;     // Clock phase

  reg [$clog2(CLKS_PER_HALF_BIT*2)-1:0] r_SPI_Clk_Count;
  reg r_SPI_Clk;
  reg [4:0] r_SPI_Clk_Edges;
  reg r_Leading_Edge;
  reg r_Trailing_Edge;
  reg       r_TX_DV;
  reg [7:0] r_TX_Byte;

  reg [2:0] r_RX_Bit_Count;
  reg [2:0] r_TX_Bit_Count;

  // CPOL: Clock Polarity
  // CPOL=0 means clock idles at 0, leading edge is rising edge.
  // CPOL=1 means clock idles at 1, leading edge is falling edge.
  assign w_CPOL  = (SPI_MODE == 2) | (SPI_MODE == 3);

  // CPHA: Clock Phase
  // CPHA=0 means the "out" side changes the data on trailing edge of clock
  //              the "in" side captures data on leading edge of clock
  // CPHA=1 means the "out" side changes the data on leading edge of clock
  //              the "in" side captures data on the trailing edge of clock
  assign w_CPHA  = (SPI_MODE == 1) | (SPI_MODE == 3);



  // Purpose: Generate SPI Clock correct number of times when DV pulse comes
  always @(posedge i_Clk or negedge i_Rst_L)
  begin
    if (~i_Rst_L)
    begin
      o_TX_Ready      <= 1'b0;
      r_SPI_Clk_Edges <= 0;
      r_Leading_Edge  <= 1'b0;
      r_Trailing_Edge <= 1'b0;
      r_SPI_Clk       <= w_CPOL; // assign default state to idle state
      r_SPI_Clk_Count <= 0;
    end
    else
    begin

      // Default assignments
      r_Leading_Edge  <= 1'b0;
      r_Trailing_Edge <= 1'b0;
      
      if (i_TX_DV)
      begin
        o_TX_Ready      <= 1'b0;
        r_SPI_Clk_Edges <= 16;  // Total # edges in one byte ALWAYS 16
      end
      else if (r_SPI_Clk_Edges > 0)
      begin
        o_TX_Ready <= 1'b0;
        
        if (r_SPI_Clk_Count == CLKS_PER_HALF_BIT*2-1)
        begin
          r_SPI_Clk_Edges <= r_SPI_Clk_Edges - 1'b1;
          r_Trailing_Edge <= 1'b1;
          r_SPI_Clk_Count <= 0;
          r_SPI_Clk       <= ~r_SPI_Clk;
        end
        else if (r_SPI_Clk_Count == CLKS_PER_HALF_BIT-1)
        begin
          r_SPI_Clk_Edges <= r_SPI_Clk_Edges - 1'b1;
          r_Leading_Edge  <= 1'b1;
          r_SPI_Clk_Count <= r_SPI_Clk_Count + 1'b1;
          r_SPI_Clk       <= ~r_SPI_Clk;
        end
        else
        begin
          r_SPI_Clk_Count <= r_SPI_Clk_Count + 1'b1;
        end
      end  
      else
      begin
        o_TX_Ready <= 1'b1;
      end
      
      
    end // else: !if(~i_Rst_L)
  end // always @ (posedge i_Clk or negedge i_Rst_L)


  // Purpose: Register i_TX_Byte when Data Valid is pulsed.
  // Keeps local storage of byte in case higher level module changes the data
  always @(posedge i_Clk or negedge i_Rst_L)
  begin
    if (~i_Rst_L)
    begin
      r_TX_Byte <= 8'h00;
      r_TX_DV   <= 1'b0;
    end
    else
      begin
        r_TX_DV <= i_TX_DV; // 1 clock cycle delay
        if (i_TX_DV)
        begin
          r_TX_Byte <= i_TX_Byte;
        end
      end // else: !if(~i_Rst_L)
  end // always @ (posedge i_Clk or negedge i_Rst_L)


  // Purpose: Generate MOSI data
  // Works with both CPHA=0 and CPHA=1
  always @(posedge i_Clk or negedge i_Rst_L)
  begin
    if (~i_Rst_L)
    begin
      o_SPI_MOSI     <= 1'b0;
      r_TX_Bit_Count <= 3'b111; // send MSb first
    end
    else
    begin
      // If ready is high, reset bit counts to default
      if (o_TX_Ready)
      begin
        r_TX_Bit_Count <= 3'b111;
      end
      // Catch the case where we start transaction and CPHA = 0
      else if (r_TX_DV & ~w_CPHA)
      begin
        o_SPI_MOSI     <= r_TX_Byte[3'b111];
        r_TX_Bit_Count <= 3'b110;
      end
      else if ((r_Leading_Edge & w_CPHA) | (r_Trailing_Edge & ~w_CPHA))
      begin
        r_TX_Bit_Count <= r_TX_Bit_Count - 1'b1;
        o_SPI_MOSI     <= r_TX_Byte[r_TX_Bit_Count];
      end
    end
  end


  // Purpose: Read in MISO data.
  always @(posedge i_Clk or negedge i_Rst_L)
  begin
    if (~i_Rst_L)
    begin
      o_RX_Byte      <= 8'h00;
      o_RX_DV        <= 1'b0;
      r_RX_Bit_Count <= 3'b111;
    end
    else
    begin

      // Default Assignments
      o_RX_DV   <= 1'b0;

      if (o_TX_Ready) // Check if ready is high, if so reset bit count to default
      begin
        r_RX_Bit_Count <= 3'b111;
      end
      else if ((r_Leading_Edge & ~w_CPHA) | (r_Trailing_Edge & w_CPHA))
      begin
        o_RX_Byte[r_RX_Bit_Count] <= i_SPI_MISO;  // Sample data
        r_RX_Bit_Count            <= r_RX_Bit_Count - 1'b1;
        if (r_RX_Bit_Count == 3'b000)
        begin
          o_RX_DV   <= 1'b1;   // Byte done, pulse Data Valid
        end
      end
    end
  end
  
  
  // Purpose: Add clock delay to signals for alignment.
  always @(posedge i_Clk or negedge i_Rst_L)
  begin
    if (~i_Rst_L)
    begin
      o_SPI_Clk  <= w_CPOL;
    end
    else
      begin
        o_SPI_Clk <= r_SPI_Clk;
      end // else: !if(~i_Rst_L)
  end // always @ (posedge i_Clk or negedge i_Rst_L)
  

endmodule // SPI_Master


module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_JK_FF
#(
    parameter Default = 1'b0
)
(
   input J,
   input C,
   input K,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        if (~J & K)
            state <= 1'b0;
         else if (J & ~K)
            state <= 1'b1;
         else if (J & K)
            state <= ~state;
    end

    initial begin
        state = Default;
    end
endmodule


module spiden (
  input spi_miso,
  input [15:0] Address,
  input clk,
  input st,
  input [15:0] DataIn,
  input ld,
  output spi_clk,
  output spi_mosi,
  output Busy,
  output [15:0] data_out
);
  wire s0;
  wire [7:0] s1;
  wire Tx_Ready;
  wire Rx_Ready;
  wire [7:0] data_Rx;
  wire load;
  wire [7:0] ramCommand;
  wire Selected;
  wire [15:0] s2;
  wire [7:0] ramAdres_0;
  wire [7:0] ramAdres_1;
  wire [2:0] s3;
  wire [7:0] ramData_1;
  wire [7:0] ramData_0;
  wire [7:0] s4;
  wire [15:0] s5;
  wire store;
  wire s6;
  wire s7;
  wire s8;
  wire busy_N;
  wire s9;
  wire rstSpi;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire [7:0] s14;
  wire s15;
  wire [7:0] s16;
  wire s17;
  wire s18;
  wire s19;
  wire s20;
  wire s21;
  wire s22;
  wire s23;
  wire s24;
  wire s25;
  assign s17 = (st & clk);
  assign s19 = (ld & clk);
  // SPI_Master
  SPI_Master SPI_Master_i0 (
    .i_Rst_L( s0 ),
    .i_Clk( clk ),
    .i_TX_Byte( s1 ),
    .i_TX_DV( Tx_Ready ),
    .i_SPI_MISO( spi_miso ),
    .o_TX_Ready( Tx_Ready ),
    .o_RX_DV( Rx_Ready ),
    .o_RX_Byte( data_Rx ),
    .o_SPI_Clk( spi_clk ),
    .o_SPI_MOSI( spi_mosi )
  );
  // RamAddress
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( Address ),
    .C( clk ),
    .en( Selected ),
    .Q( s2 )
  );
  // RamData
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( DataIn ),
    .C( clk ),
    .en( Selected ),
    .Q( s5 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( s17 ),
    .D( store ),
    .C( 1'b1 ),
    .Clr( s18 ),
    .Q( store )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i4 (
    .Set( s19 ),
    .D( load ),
    .C( 1'b1 ),
    .Clr( s20 ),
    .Q( load )
  );
  assign s20 = (rstSpi & ~ ld);
  assign s18 = (rstSpi & ~ st);
  assign ramCommand[0] = load;
  assign ramCommand[1] = 1'b1;
  assign ramCommand[2] = 1'b0;
  assign ramCommand[3] = 1'b0;
  assign ramCommand[4] = 1'b0;
  assign ramCommand[5] = 1'b0;
  assign ramCommand[6] = 1'b0;
  assign ramCommand[7] = 1'b0;
  assign Selected = (load | store);
  assign ramAdres_0 = s2[7:0];
  assign ramAdres_1 = s2[15:8];
  assign ramData_0 = s5[7:0];
  assign ramData_1 = s5[15:8];
  Mux_8x1_NBits #(
    .Bits(8)
  )
  Mux_8x1_NBits_i5 (
    .sel( s3 ),
    .in_0( ramCommand ),
    .in_1( ramAdres_1 ),
    .in_2( ramAdres_0 ),
    .in_3( ramData_1 ),
    .in_4( ramData_0 ),
    .in_5( 8'b1000001 ),
    .in_6( 8'b1001110 ),
    .in_7( 8'b1100000 ),
    .out( s4 )
  );
  assign busy_N = (Rx_Ready & ((~ s6 & ~ s7 & s8) | (s11 & load)));
  Mux_2x1 Mux_2x1_i6 (
    .sel( rstSpi ),
    .in_0( Selected ),
    .in_1( 1'b0 ),
    .out( s0 )
  );
  assign s9 = (Selected ^ rstSpi);
  assign s10 = ((s11 | s12) & load);
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i7 (
    .D( data_Rx ),
    .C( Rx_Ready ),
    .en( s13 ),
    .Q( s14 )
  );
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i8 (
    .D( data_Rx ),
    .C( Rx_Ready ),
    .en( s15 ),
    .Q( s16 )
  );
  assign s13 = (s11 & load);
  assign s15 = (s12 & load);
  assign Busy = (~ rstSpi & Selected);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i9 (
    .Set( 1'b0 ),
    .D( s21 ),
    .C( Tx_Ready ),
    .Clr( rstSpi ),
    .Q( s22 ),
    .\~Q ( s21 )
  );
  // Reset
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i10 (
    .J( busy_N ),
    .C( clk ),
    .K( s9 ),
    .Q( rstSpi )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i11 (
    .sel( s10 ),
    .in_0( s4 ),
    .in_1( 8'b0 ),
    .out( s1 )
  );
  assign data_out[7:0] = s14;
  assign data_out[15:8] = s16;
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i12 (
    .Set( 1'b0 ),
    .D( s23 ),
    .C( s22 ),
    .Clr( rstSpi ),
    .Q( s24 ),
    .\~Q ( s23 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i13 (
    .Set( 1'b0 ),
    .D( s25 ),
    .C( s24 ),
    .Clr( rstSpi ),
    .\~Q ( s25 )
  );
  assign s3[0] = s21;
  assign s3[1] = s23;
  assign s3[2] = s25;
  assign s6 = s3[0];
  assign s7 = s3[1];
  assign s8 = s3[2];
  assign s11 = (s8 & ~ s7 & ~ s6);
  assign s12 = (s6 & s6 & ~ s8);
endmodule

module OpCode
  (
    input clk,
    input rst,
    input instructionInput ,
    input [15:0]ProgramCounter,
    output reg [15:0] opcoder,
    output PcClock,
    output PcShifter
  );

  reg[15:0] instructionRegister=15'h0;
  reg[5:0] CounterRegister=5'h0;
  reg pcClockHold=1'h0;
  reg pcwireshifter;
  reg [4:0] shiftIndex=5'h10;

  reg state=1'b0;
  reg clockon= 1'b0;
  assign PcClock =pcClockHold;
  assign PcShifter=pcwireshifter;

  always @( posedge clk)
  begin
    if(pcClockHold ==0)
    begin
      if (rst)
      begin
        pcClockHold<=1;
        instructionRegister<= 15'h0;
        CounterRegister<= 5'h0;
        shiftIndex<= 5'h10;
        opcoder<=15'h0;
        state<=1'b0;
        clockon<=0;
        pcwireshifter<=0;
      end
      else
      begin
        if(clockon)
        begin
          pcClockHold<=1;
          clockon<=0;
        end
        else
        begin
          if(state)
          begin

            pcwireshifter<= 0;
            instructionRegister <= (instructionRegister >> 1) | instructionInput<<15;
            CounterRegister <= CounterRegister + 1;
            if(CounterRegister == 5'h10)
            begin
              opcoder<=instructionRegister;
              CounterRegister<=5'h0;
              clockon<= 1;
              state<=1'b0;
              instructionRegister<=15'h0;
            end
          end
          else
          begin
            pcwireshifter<=  ProgramCounter [shiftIndex-1] ;
            shiftIndex<=shiftIndex-1;
            if(shiftIndex==5'h1)
            begin
              shiftIndex<=5'h10;
              state<=1'b1;
            end
          end

        end
      end

    end
    else
    begin
      opcoder<=15'h0;
      pcClockHold<=0;
    end
  end




endmodule


module singExtend (
  input [15:0] inst, // instruction word
  output [15:0] \4S , // The four bits taken from Rs.
  output [15:0] \8SD , // The eight bits taken from Rs,Rd with sign extension.
  output [15:0] \4D  // The four bits taken from Rd.

);
  wire s0;
  assign \4D [3:0] = inst[7:4];
  assign \4D [15:4] = 12'b0;
  assign \4S [3:0] = inst[3:0];
  assign \4S [15:4] = 12'b0;
  assign s0 = inst[7];
  assign \8SD [6:0] = inst[6:0];
  assign \8SD [7] = s0;
  assign \8SD [8] = s0;
  assign \8SD [9] = s0;
  assign \8SD [10] = s0;
  assign \8SD [11] = s0;
  assign \8SD [12] = s0;
  assign \8SD [13] = s0;
  assign \8SD [14] = s0;
  assign \8SD [15] = s0;
endmodule

module Driver
(
    input in,
    input sel,
    output out
);
    assign out = (sel == 1'b1)? in : 1'bz;
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module controllogic (
  input A,
  input B,
  input C,
  input D,
  input E,
  input F,
  input G,
  output muxb0,
  output muxb1,
  output muxb2,
  output src2D,
  output aluop0,
  output aluop1,
  output aluop2,
  output aluop3,
  output aluop4,
  output WE,
  output sf,
  output alu2D,
  output iem0,
  output iem1,
  output br0,
  output br1,
  output br2,
  output muxA,
  output ld,
  output st,
  output abs,
  output ioW,
  output ioR,
  output stPC,
  output Reti,
  output randomSel,
  output timerSel
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  assign s6 = ~ A;
  assign s0 = ~ B;
  assign s1 = ~ C;
  assign s2 = ~ D;
  assign s3 = ~ E;
  assign s5 = ~ F;
  assign s4 = ~ G;
  assign muxb0 = ~ (~ (A & s0 & s1 & s2 & s3 & F & s4) & ~ (A & s0 & s1 & s2 & E & F & G) & ~ (A & s0 & s1 & D & s3 & s5 & s4) & ~ (s6 & s1 & D & E & F & s4) & ~ (s6 & B & C & s3 & s5 & s4) & ~ (s6 & s0 & s1 & D & F & s4) & ~ (s6 & s0 & s1 & D & E & s4) & ~ (s6 & s0 & C & s2 & s3 & s4) & ~ (s6 & B & s1 & s2 & s3 & G) & ~ (s6 & C & D & s5 & G) & ~ (s6 & C & s2 & E & G) & ~ (s6 & B & C & E & G) & ~ (s6 & B & C & s2 & E));
  assign muxb1 = ~ (~ (A & s0 & s1 & s2 & E & F & s4) & ~ (s6 & C & s2 & s3 & s5 & G) & ~ (s6 & B & s1 & s2 & s3 & s4) & ~ (A & s0 & s1 & s2 & s3 & G) & ~ (A & s0 & s1 & s2 & s3 & s5) & ~ (s6 & s1 & D & F & G) & ~ (s6 & C & D & s5 & s4) & ~ (s6 & B & C & s5 & G) & ~ (s6 & B & C & F & s4) & ~ (s6 & C & s2 & E & s4) & ~ (s6 & s0 & s1 & D & G) & ~ (s6 & B & D & E) & ~ (s6 & B & C & E));
  assign muxb2 = ~ (~ (s6 & B & C & D & E & F & G) & ~ (s6 & C & s2 & s3 & s5 & s4) & ~ (s6 & B & s2 & s3 & F & G) & ~ (s6 & B & s1 & s3 & F & G) & ~ (A & s0 & s1 & s3 & s5 & s4) & ~ (s6 & s0 & s1 & D & F & s4) & ~ (s6 & s0 & C & D & s5 & G) & ~ (A & s0 & s1 & s2 & F & G) & ~ (s6 & s0 & C & s2 & s3 & s4) & ~ (s6 & s0 & C & s2 & E & G) & ~ (s6 & B & s1 & s2 & s3 & G) & ~ (A & s0 & s1 & s2 & s3 & s4) & ~ (s6 & s1 & D & E & s4));
  assign src2D = ~ (~ (s6 & s0 & s1 & s2 & s3 & s5 & G) & ~ (s6 & B & s1 & D & s3 & F & G) & ~ (s6 & B & s1 & D & E & s5 & G) & ~ (s6 & B & C & s2 & s3 & s5 & G) & ~ (A & s0 & s1 & s2 & s3 & s5 & s4) & ~ (s6 & B & D & E & F & s4) & ~ (s6 & B & C & D & E & F));
  assign aluop0 = ~ (~ (s6 & s0 & s1 & D & E & F & s4) & ~ (s6 & s0 & C & s2 & s3 & s5 & G) & ~ (s6 & s0 & C & s2 & s3 & F & s4) & ~ (s6 & s0 & C & D & E & F & G) & ~ (s6 & s1 & s2 & s3 & F & G) & ~ (s6 & s0 & s1 & E & s5 & G) & ~ (s6 & B & s1 & s2 & F));
  assign aluop1 = ~ (~ (s6 & s0 & C & D & s3 & F & G) & ~ (A & s0 & s1 & s2 & E & s5 & G) & ~ (A & s0 & s1 & s2 & E & F & s4) & ~ (s6 & B & s1 & D & s3 & s4) & ~ (s6 & s0 & C & D & E & s5) & ~ (s6 & B & s1 & D & s3 & s5) & ~ (s6 & B & s1 & s2 & E));
  assign aluop2 = ~ (~ (s6 & B & s1 & D & s3 & F & s4) & ~ (A & s0 & s1 & s2 & E & s5 & G) & ~ (A & s0 & s1 & s2 & E & F & s4) & ~ (s6 & s0 & s2 & E & F & G) & ~ (s6 & s0 & D & s3 & s5 & s4) & ~ (s6 & s0 & C & s3 & F & G) & ~ (s6 & s0 & C & s2 & E & F) & ~ (s6 & s0 & C & D & s5) & ~ (s6 & s0 & C & D & s3));
  assign aluop3 = ~ (~ (s6 & s0 & D & E & F & G) & ~ (s6 & s0 & C & D & F & s4) & ~ (s6 & s0 & s2 & E & s5) & ~ (s6 & B & s1 & s3 & s5) & ~ (s6 & s0 & C & s2 & s3) & ~ (s6 & B & s1 & s2 & s3) & ~ (s0 & s1 & s2 & E & s5 & G) & ~ (s0 & s1 & s2 & E & F & s4));
  assign aluop4 = ~ (~ (s6 & B & C & s2 & s3 & s5 & G) & ~ (s6 & B & C & s2 & s3 & F & s4) & ~ (A & s0 & s1 & s2 & s3 & s5 & s4) & ~ (s6 & s1 & D & E & s5 & s4) & ~ (s6 & s0 & s1 & E & F & s4) & ~ (s6 & s0 & s1 & s2 & F & s4) & ~ (s6 & s0 & C & D & s3 & G) & ~ (s6 & B & s1 & s2 & E & G) & ~ (s6 & B & s1 & D & s3 & G) & ~ (s6 & s0 & s3 & F & G) & ~ (s6 & s0 & D & s5 & s4) & ~ (s6 & s0 & D & E & s5) & ~ (s6 & s0 & C & E & s5) & ~ (s0 & s1 & s2 & s3 & F & G));
  assign WE = ~ (~ (s6 & D & s3 & F & s4) & ~ (s6 & s1 & E & s5 & s4) & ~ (s6 & s1 & E & F & G) & ~ (s6 & C & s2 & s3 & s4) & ~ (s6 & s1 & D & s3 & s5) & ~ (s6 & C & s2 & s3 & F) & ~ (s6 & s0 & D & s5) & ~ (s6 & s1 & s2 & E) & ~ (s6 & s0 & D & s3) & ~ (s6 & s0 & s1 & D) & ~ (s6 & s0 & C & s2) & ~ (s0 & s1 & D & s3 & s5 & s4) & ~ (s0 & s1 & s2 & G) & ~ (s0 & s1 & s2 & F));
  assign sf = ~ (~ (s6 & s1 & D & s3 & s5 & s4) & ~ (s6 & s0 & s2 & F & s4) & ~ (s6 & s0 & D & F & G) & ~ (s6 & s0 & s1 & F & G) & ~ (s6 & s0 & C & s5) & ~ (s6 & B & s1 & s2) & ~ (s6 & s0 & E) & ~ (s0 & s1 & s2 & E & s5 & G) & ~ (s0 & s1 & s2 & E & F & s4));
  assign alu2D = ~ (~ (s6 & C & s2 & s3 & F & G) & ~ (s6 & s1 & D & s3 & s4) & ~ (s6 & s1 & D & s3 & s5) & ~ (s6 & s0 & E & s5) & ~ (s6 & s0 & s2 & F) & ~ (s6 & s0 & s1 & F) & ~ (s6 & s1 & s2 & E) & ~ (s6 & s0 & C & s3) & ~ (s0 & s1 & s2 & E & s5 & G) & ~ (s0 & s1 & s2 & E & F & s4));
  assign iem0 = ~ (~ (s6 & s0 & C & s2 & s3 & s5 & G) & ~ (A & s0 & s1 & s2 & s3 & s5 & G) & ~ (A & s0 & s1 & s2 & E & F & s4) & ~ (s6 & C & D & E & s5 & s4) & ~ (s6 & s0 & C & D & s5 & s4) & ~ (s6 & B & C & D & F & s4) & ~ (s6 & s0 & C & s2 & E & s4) & ~ (s6 & B & s1 & s2 & s3 & s4) & ~ (s6 & s1 & D & E & G) & ~ (s6 & s0 & s1 & D & G));
  assign iem1 = ~ (~ (s6 & B & s1 & D & E & s5 & G) & ~ (s6 & B & C & D & E & F & s4));
  assign br0 = ~ (~ (s6 & B & C & s2 & E & F & G) & ~ (s6 & B & C & D & s5 & G) & ~ (s6 & B & C & D & s3 & s5));
  assign br1 = ~ (~ (s6 & B & C & s2 & E & s5 & G) & ~ (s6 & B & C & s2 & E & F & s4) & ~ (s6 & B & C & D & s3 & s5));
  assign br2 = ~ (~ (s6 & B & C & D & s3 & s5 & G) & ~ (s6 & B & C & s2 & E & s4) & ~ (s6 & B & C & s2 & E & F));
  assign muxA = ~ (~ (s6 & B & s1 & D & E & s5 & s4) & ~ (s6 & B & C & s2 & s3 & F & s4) & ~ (A & s0 & s1 & s2 & s3 & G) & ~ (A & s0 & s1 & s2 & s3 & F));
  assign ld = ~ (~ (s6 & B & s1 & D & E & s5 & s4) & ~ (s6 & B & s1 & D & E & F & G) & ~ (s6 & B & C & s2 & s3 & s4));
  assign st = ~ (~ (s6 & B & s1 & D & s3 & F & G) & ~ (s6 & B & s1 & D & E & s5 & G) & ~ (s6 & B & s1 & D & E & F & s4) & ~ (s6 & B & C & s2 & s3 & s5 & G));
  assign abs = ~ (~ (s6 & B & C & D & E & s5 & s4) & ~ (A & s0 & s1 & s2 & E & s5 & s4) & ~ (s6 & B & C & D & s3 & F));
  assign ioW = ~ (~ (A & s0 & s1 & s2 & s3 & s5 & s4) & ~ (s6 & B & C & D & E & F));
  assign ioR = ~ (~ (A & s0 & s1 & s2 & s3 & G) & ~ (A & s0 & s1 & s2 & s3 & F));
  assign stPC = (s6 & B & C & D & s3 & F & s4);
  assign Reti = (A & s0 & s1 & s2 & E & s5 & s4);
  assign randomSel = (A & s0 & s1 & s2 & E & F & G);
  assign timerSel = (A & s0 & s1 & D & s3 & s5 & s4);
endmodule

module Demux4
#(
    parameter Default = 0 
)
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    output out_8,
    output out_9,
    output out_10,
    output out_11,
    output out_12,
    output out_13,
    output out_14,
    output out_15,
    input [3:0] sel,
    input in
);
    assign out_0 = (sel == 4'h0)? in : Default;
    assign out_1 = (sel == 4'h1)? in : Default;
    assign out_2 = (sel == 4'h2)? in : Default;
    assign out_3 = (sel == 4'h3)? in : Default;
    assign out_4 = (sel == 4'h4)? in : Default;
    assign out_5 = (sel == 4'h5)? in : Default;
    assign out_6 = (sel == 4'h6)? in : Default;
    assign out_7 = (sel == 4'h7)? in : Default;
    assign out_8 = (sel == 4'h8)? in : Default;
    assign out_9 = (sel == 4'h9)? in : Default;
    assign out_10 = (sel == 4'ha)? in : Default;
    assign out_11 = (sel == 4'hb)? in : Default;
    assign out_12 = (sel == 4'hc)? in : Default;
    assign out_13 = (sel == 4'hd)? in : Default;
    assign out_14 = (sel == 4'he)? in : Default;
    assign out_15 = (sel == 4'hf)? in : Default;
endmodule


module Mux_16x1_NBits #(
    parameter Bits = 2
)
(
    input [3:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    input [(Bits - 1):0] in_8,
    input [(Bits - 1):0] in_9,
    input [(Bits - 1):0] in_10,
    input [(Bits - 1):0] in_11,
    input [(Bits - 1):0] in_12,
    input [(Bits - 1):0] in_13,
    input [(Bits - 1):0] in_14,
    input [(Bits - 1):0] in_15,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule


module RegisterBlock (
  input [15:0] DataIn,
  input WE,
  input clk,
  input [3:0] src,
  input [3:0] Dest,
  output [15:0] RDest,
  output [15:0] Rsrc
);
  wire s0;
  wire [15:0] s1;
  wire s2;
  wire [15:0] s3;
  wire s4;
  wire [15:0] s5;
  wire s6;
  wire [15:0] s7;
  wire s8;
  wire [15:0] s9;
  wire s10;
  wire [15:0] s11;
  wire s12;
  wire [15:0] s13;
  wire s14;
  wire [15:0] s15;
  wire s16;
  wire [15:0] s17;
  wire s18;
  wire [15:0] s19;
  wire s20;
  wire [15:0] s21;
  wire s22;
  wire [15:0] s23;
  wire s24;
  wire [15:0] s25;
  wire s26;
  wire [15:0] s27;
  wire s28;
  wire [15:0] s29;
  wire s30;
  wire [15:0] s31;
  Demux4 #(
    .Default(0)
  )
  Demux4_i0 (
    .sel( Dest ),
    .in( WE ),
    .out_0( s0 ),
    .out_1( s2 ),
    .out_2( s4 ),
    .out_3( s6 ),
    .out_4( s8 ),
    .out_5( s10 ),
    .out_6( s12 ),
    .out_7( s14 ),
    .out_8( s16 ),
    .out_9( s18 ),
    .out_10( s20 ),
    .out_11( s22 ),
    .out_12( s24 ),
    .out_13( s26 ),
    .out_14( s28 ),
    .out_15( s30 )
  );
  // R0
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( DataIn ),
    .C( clk ),
    .en( s0 ),
    .Q( s1 )
  );
  // R1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( DataIn ),
    .C( clk ),
    .en( s2 ),
    .Q( s3 )
  );
  // R2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( DataIn ),
    .C( clk ),
    .en( s4 ),
    .Q( s5 )
  );
  // R3
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( DataIn ),
    .C( clk ),
    .en( s6 ),
    .Q( s7 )
  );
  // R4
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( DataIn ),
    .C( clk ),
    .en( s8 ),
    .Q( s9 )
  );
  // R5
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i6 (
    .D( DataIn ),
    .C( clk ),
    .en( s10 ),
    .Q( s11 )
  );
  // R6
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i7 (
    .D( DataIn ),
    .C( clk ),
    .en( s12 ),
    .Q( s13 )
  );
  // R7
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i8 (
    .D( DataIn ),
    .C( clk ),
    .en( s14 ),
    .Q( s15 )
  );
  // R8
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i9 (
    .D( DataIn ),
    .C( clk ),
    .en( s16 ),
    .Q( s17 )
  );
  // R9
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i10 (
    .D( DataIn ),
    .C( clk ),
    .en( s18 ),
    .Q( s19 )
  );
  // R10
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i11 (
    .D( DataIn ),
    .C( clk ),
    .en( s20 ),
    .Q( s21 )
  );
  // R11
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i12 (
    .D( DataIn ),
    .C( clk ),
    .en( s22 ),
    .Q( s23 )
  );
  // R12
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i13 (
    .D( DataIn ),
    .C( clk ),
    .en( s24 ),
    .Q( s25 )
  );
  // BP
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i14 (
    .D( DataIn ),
    .C( clk ),
    .en( s26 ),
    .Q( s27 )
  );
  // SP
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i15 (
    .D( DataIn ),
    .C( clk ),
    .en( s28 ),
    .Q( s29 )
  );
  // RA
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i16 (
    .D( DataIn ),
    .C( clk ),
    .en( s30 ),
    .Q( s31 )
  );
  Mux_16x1_NBits #(
    .Bits(16)
  )
  Mux_16x1_NBits_i17 (
    .sel( Dest ),
    .in_0( s1 ),
    .in_1( s3 ),
    .in_2( s5 ),
    .in_3( s7 ),
    .in_4( s9 ),
    .in_5( s11 ),
    .in_6( s13 ),
    .in_7( s15 ),
    .in_8( s17 ),
    .in_9( s19 ),
    .in_10( s21 ),
    .in_11( s23 ),
    .in_12( s25 ),
    .in_13( s27 ),
    .in_14( s29 ),
    .in_15( s31 ),
    .out( RDest )
  );
  Mux_16x1_NBits #(
    .Bits(16)
  )
  Mux_16x1_NBits_i18 (
    .sel( src ),
    .in_0( s1 ),
    .in_1( s3 ),
    .in_2( s5 ),
    .in_3( s7 ),
    .in_4( s9 ),
    .in_5( s11 ),
    .in_6( s13 ),
    .in_7( s15 ),
    .in_8( s17 ),
    .in_9( s19 ),
    .in_10( s21 ),
    .in_11( s23 ),
    .in_12( s25 ),
    .in_13( s27 ),
    .in_14( s29 ),
    .in_15( s31 ),
    .out( Rsrc )
  );
endmodule

module Mux_4x1
(
    input [1:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    output reg out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


// Register for storing large constants.
// There is a 1-bit command describing this register. 
// In this way, 15 bits can be stored (the 16th bit 
// activates the writing of this register and therefore 
// is always one). The 16th bit will be set according 
// to the 'immediate extend mode' (iem).
module ImReg (
  input en, // enables storage
  input [1:0] iem, // immediate extend mode (0: sign extend; 1: extend with 0, 2:extend with S0, 3:extend with D0)
  input C,
  input [15:0] inst, // the current instruction
  output [15:0] imm // The constant of register contents and bit 8.

);
  wire [14:0] s0;
  wire [14:0] s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  assign s2 = inst[0];
  assign s3 = inst[4];
  assign s0 = inst[14:0];
  // imm
  DIG_Register_BUS #(
    .Bits(15)
  )
  DIG_Register_BUS_i0 (
    .D( s0 ),
    .C( C ),
    .en( en ),
    .Q( s1 )
  );
  assign s5 = s1[14];
  Mux_4x1 Mux_4x1_i1 (
    .sel( iem ),
    .in_0( s5 ),
    .in_1( 1'b0 ),
    .in_2( s2 ),
    .in_3( s3 ),
    .out( s4 )
  );
  assign imm[14:0] = s1;
  assign imm[15] = s4;
endmodule

module DIG_Neg #(
    parameter Bits = 1
)
(
      input signed [(Bits-1):0] in,
      output signed [(Bits-1):0] out
);
    assign out = -in;
endmodule


module DIG_Mul_unsigned #(
    parameter Bits = 1
)
(
    
      input [(Bits-1):0] a,
      input [(Bits-1):0] b,
      output [(Bits*2-1):0] mul
    
);
    assign mul = a * b;
endmodule


module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_16x1
(
    input [3:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    input in_4,
    input in_5,
    input in_6,
    input in_7,
    input in_8,
    input in_9,
    input in_10,
    input in_11,
    input in_12,
    input in_13,
    input in_14,
    input in_15,
    output reg out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule


module Mux_8x1
(
    input [2:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    input in_4,
    input in_5,
    input in_6,
    input in_7,
    output reg out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_CounterPreset #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule


module DriverBus#(
    parameter Bits = 2
)
(
    input [(Bits-1):0] in,
    input sel,
    output [(Bits-1):0] out
);
    assign out = (sel == 1'b1)? in : {Bits{1'bz}};
endmodule

module timer (
  input [15:0] dOut,
  input [15:0] Addr,
  input ioW,
  input ioR,
  input C,
  input InterLock,
  input [15:0] timerConfigAddr,
  input [15:0] timerTargetAddr,
  input [15:0] timerResetAddr,
  input [15:0] timerReadAddr,
  output [15:0] TimerOut,
  output \timer?nterrupt 
);
  wire s0;
  wire s1;
  wire s2;
  wire timer_en;
  wire [6:0] s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire [2:0] s11;
  wire s12;
  wire s13;
  wire s14;
  wire [15:0] s15;
  wire [15:0] s16;
  wire [15:0] s17;
  wire s18;
  wire s19;
  wire s20;
  wire s21;
  wire s22;
  wire [2:0] timerPrescaler;
  wire s23;
  wire s24;
  wire s25;
  wire s26;
  wire [15:0] s27;
  wire s28;
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i0 (
    .a( Addr ),
    .b( timerResetAddr ),
    .\= ( s0 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i1 (
    .a( Addr ),
    .b( timerTargetAddr ),
    .\= ( s13 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i2 (
    .a( timerReadAddr ),
    .b( dOut ),
    .\= ( s25 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i3 (
    .a( Addr ),
    .b( timerConfigAddr ),
    .\= ( s28 )
  );
  assign s1 = (dOut[0] & (s0 & ioW));
  assign s14 = (s13 & ioW);
  assign s24 = (s25 & ioR);
  assign s26 = (s28 & ioW);
  // Reset
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i4 (
    .J( s1 ),
    .C( C ),
    .K( 1'b1 ),
    .Q( s2 )
  );
  // target
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( dOut ),
    .C( C ),
    .en( s14 ),
    .Q( s15 )
  );
  // Config
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i6 (
    .D( dOut ),
    .C( C ),
    .en( s26 ),
    .Q( s27 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i7 (
    .a( s15 ),
    .b( 16'b0 ),
    .\> ( s19 ),
    .\= ( s20 )
  );
  assign timer_en = s27[0];
  assign timerPrescaler = s27[3:1];
  DIG_Counter_Nbit #(
    .Bits(7)
  )
  DIG_Counter_Nbit_i8 (
    .en( timer_en ),
    .C( C ),
    .clr( 1'b0 ),
    .out( s3 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i9 (
    .sel( s19 ),
    .in_0( 16'b0 ),
    .in_1( s15 ),
    .out( s16 )
  );
  assign s4 = s3[0];
  assign s5 = s3[1];
  assign s6 = s3[2];
  assign s7 = s3[3];
  assign s8 = s3[4];
  assign s9 = s3[5];
  assign s10 = s3[6];
  Mux_8x1 Mux_8x1_i10 (
    .sel( s11 ),
    .in_0( C ),
    .in_1( s4 ),
    .in_2( s5 ),
    .in_3( s6 ),
    .in_4( s7 ),
    .in_5( s8 ),
    .in_6( s9 ),
    .in_7( s10 ),
    .out( s12 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i11 (
    .a( s16 ),
    .b( s17 ),
    .\= ( s18 )
  );
  assign \timer?nterrupt  = (~ InterLock & (~ s20 & s18));
  assign s21 = (~ s20 & ((s18 & s27[4]) | s2));
  DIG_CounterPreset #(
    .Bits(16),
    .maxValue(0)
  )
  DIG_CounterPreset_i12 (
    .en( timer_en ),
    .C( s22 ),
    .dir( 1'b0 ),
    .in( 16'b0 ),
    .ld( s21 ),
    .clr( 1'b0 ),
    .out( s17 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i13 (
    .sel( s21 ),
    .in_0( timerPrescaler ),
    .in_1( 3'b0 ),
    .out( s11 )
  );
  assign s23 = (InterLock | ((s18 & ~ s20) & ~ s21));
  DriverBus #(
    .Bits(16)
  )
  DriverBus_i14 (
    .in( s17 ),
    .sel( s24 ),
    .out( TimerOut )
  );
  Mux_2x1 Mux_2x1_i15 (
    .sel( s23 ),
    .in_0( s12 ),
    .in_1( 1'b1 ),
    .out( s22 )
  );
endmodule

module tt_um_smallcpu (
  input [7:0] \Input ,
  input clk,
  input rst_n,
  input instruction,
  output [3:0] debugOut,
  output spiClk,
  output spiMosi,
  output spiCS,
  output PCOut,
  output [3:0] spiDeg,
  output [7:0] \Output 
);
  wire muxA;
  wire [15:0] s0;
  wire [15:0] DataOut;
  wire [15:0] s1;
  wire [2:0] muxB;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [15:0] CurrentOpcode;
  wire [3:0] s7;
  wire [3:0] s8;
  wire [7:0] OPcode;
  wire [2:0] s9;
  wire [15:0] AddrOut;
  wire [15:0] din_bus;
  wire [15:0] iow_Din;
  wire [15:0] s10;
  wire [15:0] timer_in;
  wire [15:0] RandomNUM;
  wire [15:0] s11;
  wire [1:0] s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire [2:0] br;
  wire s18;
  wire sf;
  wire s19;
  wire s20;
  wire [15:0] FlagOut;
  wire WE;
  wire pcClock;
  wire imm;
  wire [1:0] iem;
  wire [15:0] s21;
  wire s22;
  wire [15:0] pcOut;
  wire [15:0] s23;
  wire [15:0] s24;
  wire abs;
  wire [15:0] s25;
  wire [3:0] sel;
  wire [15:0] s26;
  wire [15:0] s27;
  wire [15:0] s28;
  wire [15:0] s29;
  wire [15:0] s30;
  wire [15:0] s31;
  wire [15:0] s32;
  wire [15:0] s33;
  wire [15:0] s34;
  wire [15:0] s35;
  wire [15:0] s36;
  wire [15:0] s37;
  wire [15:0] s38;
  wire s39;
  wire s40;
  wire s41;
  wire s42;
  wire s43;
  wire [4:0] aluOp;
  wire s44;
  wire s45;
  wire s46;
  wire s47;
  wire s48;
  wire s49;
  wire [15:0] s50;
  wire [15:0] s51;
  wire s52;
  wire ioW;
  wire s53;
  wire s54;
  wire s55;
  wire s56;
  wire s57;
  wire s58;
  wire s59;
  wire s60;
  wire s61;
  wire s62;
  wire s63;
  wire s64;
  wire s65;
  wire s66;
  wire s67;
  wire s68;
  wire s69;
  wire s70;
  wire s71;
  wire s72;
  wire s73;
  wire s74;
  wire s75;
  wire s76;
  wire s77;
  wire s78;
  wire s79;
  wire s80;
  wire s81;
  wire s82;
  wire s83;
  wire s84;
  wire s85;
  wire s86;
  wire s87;
  wire stPC;
  wire ld;
  wire RandomNUMSel;
  wire ioR;
  wire [6:0] s88;
  wire [6:0] s89;
  wire s90;
  wire s91;
  wire s92;
  wire s93;
  wire s94;
  wire s95;
  wire s96;
  wire s97;
  wire s98;
  wire s99;
  wire src2D;
  wire s100;
  wire s101;
  wire s102;
  wire s103;
  wire s104;
  wire alu2D;
  wire s105;
  wire s106;
  wire s107;
  wire s108;
  wire s109;
  wire st;
  wire Reti;
  wire timer_Sel;
  wire InterLock;
  wire s110;
  wire intr;
  wire s111;
  wire s112;
  wire s113;
  wire s114;
  wire inter;
  wire interEnable;
  wire s115;
  wire [15:0] s116;
  wire s117;
  wire s118;
  wire [15:0] s119;
  wire s120;
  wire [15:0] s121;
  wire s122;
  wire [15:0] s123;
  wire s124;
  wire [31:0] s125;
  wire spi_miso;
  wire [15:0] s126;
  wire s127;
  wire s128;
  wire spi_busy_ram;
  wire s129;
  wire s130;
  wire [7:0] s131;
  wire s132;
  wire s133;
  wire [7:0] s134;
  wire [7:0] outputToOutsideEnable;
  wire s135;
  wire s136;
  wire s137;
  wire s138;
  wire PCOut_temp;
  wire [2:0] s139;
  assign iow_Din[0] = \Input [0];
  assign iow_Din[1] = \Input [1];
  assign iow_Din[2] = \Input [2];
  assign iow_Din[3] = \Input [3];
  assign iow_Din[4] = \Input [4];
  assign iow_Din[5] = \Input [5];
  assign iow_Din[6] = \Input [6];
  assign iow_Din[7] = \Input [7];
  assign iow_Din[8] = 1'b0;
  assign iow_Din[9] = 1'b0;
  assign iow_Din[10] = 1'b0;
  assign iow_Din[11] = 1'b0;
  assign iow_Din[12] = 1'b0;
  assign iow_Din[13] = 1'b0;
  assign iow_Din[14] = 1'b0;
  assign iow_Din[15] = 1'b0;
  assign s112 = ~ clk;
  assign s114 = ~ clk;
  assign s120 = ~ clk;
  assign s138 = ~ rst_n;
  assign s139[0] = instruction;
  assign s139[1] = rst_n;
  assign s139[2] = clk;
  assign spi_miso = \Input [0];
  assign s135 = \Input [1];
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i0 (
    .sel( s9 ),
    .in_0( AddrOut ),
    .in_1( din_bus ),
    .in_2( iow_Din ),
    .in_3( s10 ),
    .in_4( timer_in ),
    .in_5( RandomNUM ),
    .in_6( 16'b0 ),
    .in_7( 16'b0 ),
    .out( s11 )
  );
  // *
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( s111 ),
    .C( s112 ),
    .Q( InterLock )
  );
  // *
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i2 (
    .D( s113 ),
    .C( s114 ),
    .Q( s110 )
  );
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( s25 ),
    .C( s120 ),
    .en( s118 ),
    .Q( s121 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i4 (
    .sel( rst_n ),
    .in_0( 16'b0 ),
    .in_1( s123 ),
    .out( s21 )
  );
  // SpiRam
  spiden spiden_i5 (
    .spi_miso( spi_miso ),
    .Address( s126 ),
    .clk( clk ),
    .st( 1'b0 ),
    .DataIn( DataOut ),
    .ld( 1'b0 ),
    .spi_clk( s127 ),
    .spi_mosi( s128 ),
    .Busy( spi_busy_ram ),
    .data_out( din_bus )
  );
  // OpCode
  OpCode OpCode_i6 (
    .clk( s137 ),
    .rst( s138 ),
    .instructionInput( instruction ),
    .ProgramCounter( pcOut ),
    .opcoder( CurrentOpcode ),
    .PcClock( pcClock ),
    .PcShifter( PCOut_temp )
  );
  assign spiDeg[2:0] = s139;
  assign spiDeg[3] = PCOut_temp;
  singExtend singExtend_i7 (
    .inst( CurrentOpcode ),
    .\4S ( s3 ),
    .\8SD ( s4 ),
    .\4D ( s5 )
  );
  assign s22 = ~ pcClock;
  assign spiCS = ~ spi_busy_ram;
  Driver Driver_i8 (
    .in( s127 ),
    .sel( spi_busy_ram ),
    .out( spiClk )
  );
  Driver Driver_i9 (
    .in( s128 ),
    .sel( spi_busy_ram ),
    .out( spiMosi )
  );
  Mux_2x1 Mux_2x1_i10 (
    .sel( spi_busy_ram ),
    .in_0( clk ),
    .in_1( 1'b1 ),
    .out( s137 )
  );
  assign s7 = CurrentOpcode[3:0];
  assign s8 = CurrentOpcode[7:4];
  assign OPcode = CurrentOpcode[15:8];
  // PC
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i11 (
    .D( s21 ),
    .C( s22 ),
    .en( 1'b1 ),
    .Q( pcOut )
  );
  assign s88 = OPcode[6:0];
  assign imm = OPcode[7];
  Mux_2x1_NBits #(
    .Bits(7)
  )
  Mux_2x1_NBits_i12 (
    .sel( imm ),
    .in_0( s88 ),
    .in_1( 7'b0 ),
    .out( s89 )
  );
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i13 (
    .a( pcOut ),
    .b( 16'b1 ),
    .c_i( 1'b0 ),
    .s( s10 )
  );
  assign intr = (~ InterLock & ~ imm & s110 & ~ 1'b0);
  assign debugOut[0] = pcClock;
  assign debugOut[1] = pcOut[0];
  assign debugOut[2] = pcOut[1];
  assign debugOut[3] = pcOut[2];
  assign s96 = s89[0];
  assign s95 = s89[1];
  assign s94 = s89[2];
  assign s93 = s89[3];
  assign s92 = s89[4];
  assign s91 = s89[5];
  assign s90 = s89[6];
  controllogic controllogic_i14 (
    .A( s90 ),
    .B( s91 ),
    .C( s92 ),
    .D( s93 ),
    .E( s94 ),
    .F( s95 ),
    .G( s96 ),
    .muxb0( s97 ),
    .muxb1( s98 ),
    .muxb2( s99 ),
    .src2D( src2D ),
    .aluop0( s100 ),
    .aluop1( s101 ),
    .aluop2( s102 ),
    .aluop3( s103 ),
    .aluop4( s104 ),
    .WE( WE ),
    .sf( sf ),
    .alu2D( alu2D ),
    .iem0( s105 ),
    .iem1( s106 ),
    .br0( s107 ),
    .br1( s108 ),
    .br2( s109 ),
    .muxA( muxA ),
    .ld( ld ),
    .st( st ),
    .abs( abs ),
    .ioW( ioW ),
    .ioR( ioR ),
    .stPC( stPC ),
    .Reti( Reti ),
    .randomSel( RandomNUMSel ),
    .timerSel( timer_Sel )
  );
  RegisterBlock RegisterBlock_i15 (
    .DataIn( s11 ),
    .WE( WE ),
    .clk( pcClock ),
    .src( s7 ),
    .Dest( s8 ),
    .RDest( s0 ),
    .Rsrc( DataOut )
  );
  assign s9[0] = (stPC | ld | RandomNUMSel);
  assign s9[1] = (ioR | stPC);
  assign s9[2] = (timer_Sel | RandomNUMSel);
  assign muxB[0] = s99;
  assign muxB[1] = s98;
  assign muxB[2] = s97;
  assign aluOp[0] = s104;
  assign aluOp[1] = s103;
  assign aluOp[2] = s102;
  assign aluOp[3] = s101;
  assign aluOp[4] = s100;
  assign br[0] = s109;
  assign br[1] = s108;
  assign br[2] = s107;
  assign iem[0] = s106;
  assign iem[1] = s105;
  assign s111 = ((InterLock & ~ Reti) | intr);
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i16 (
    .sel( muxA ),
    .in_0( s0 ),
    .in_1( DataOut ),
    .out( s1 )
  );
  ImReg ImReg_i17 (
    .en( imm ),
    .iem( iem ),
    .C( pcClock ),
    .inst( CurrentOpcode ),
    .imm( s2 )
  );
  assign s12 = br[1:0];
  assign sel = aluOp[3:0];
  assign s131 = DataOut[7:0];
  assign s134 = DataOut[7:0];
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i18 (
    .sel( muxB ),
    .in_0( DataOut ),
    .in_1( 16'b0 ),
    .in_2( s2 ),
    .in_3( 16'b0 ),
    .in_4( 16'b0 ),
    .in_5( s3 ),
    .in_6( s4 ),
    .in_7( s5 ),
    .out( s6 )
  );
  assign s31 = ~ s1;
  DIG_Neg #(
    .Bits(16)
  )
  DIG_Neg_i19 (
    .in( s1 ),
    .out( s32 )
  );
  assign s37[3:0] = s1[7:4];
  assign s37[7:4] = s1[3:0];
  assign s37[11:8] = s1[15:12];
  assign s37[15:12] = s1[11:8];
  assign s36[7:0] = s1[15:8];
  assign s36[15:8] = s1[7:0];
  assign s43 = s1[0];
  assign s124 = s1[15];
  assign s42 = s1[0];
  assign s41 = s1[15];
  assign s28 = (s1 & s6);
  assign s29 = (s1 | s6);
  assign s30 = (s1 ^ s6);
  assign s35[13:0] = s1[14:1];
  assign s35[14] = s124;
  assign s35[15] = s124;
  DIG_Mul_unsigned #(
    .Bits(16)
  )
  DIG_Mul_unsigned_i20 (
    .a( s1 ),
    .b( s6 ),
    .mul( s125 )
  );
  assign s38 = s125[15:0];
  Mux_4x1 Mux_4x1_i21 (
    .sel( s12 ),
    .in_0( 1'b0 ),
    .in_1( s13 ),
    .in_2( s14 ),
    .in_3( s15 ),
    .out( s16 )
  );
  assign s17 = (s16 ^ br[2]);
  // Carry
  DIG_Register DIG_Register_i22 (
    .D( s18 ),
    .C( clk ),
    .en( sf ),
    .Q( s13 )
  );
  // Zero
  DIG_Register DIG_Register_i23 (
    .D( s19 ),
    .C( clk ),
    .en( sf ),
    .Q( s14 )
  );
  // Neg
  DIG_Register DIG_Register_i24 (
    .D( s20 ),
    .C( clk ),
    .en( sf ),
    .Q( s15 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i25 (
    .sel( s17 ),
    .in_0( s10 ),
    .in_1( s23 ),
    .out( s24 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i26 (
    .sel( abs ),
    .in_0( s24 ),
    .in_1( AddrOut ),
    .out( s25 )
  );
  Mux_16x1_NBits #(
    .Bits(16)
  )
  Mux_16x1_NBits_i27 (
    .sel( sel ),
    .in_0( s6 ),
    .in_1( s26 ),
    .in_2( s27 ),
    .in_3( s28 ),
    .in_4( s29 ),
    .in_5( s30 ),
    .in_6( s31 ),
    .in_7( s32 ),
    .in_8( s33 ),
    .in_9( s34 ),
    .in_10( s35 ),
    .in_11( s36 ),
    .in_12( s37 ),
    .in_13( s38 ),
    .in_14( 16'b0 ),
    .in_15( 16'b0 ),
    .out( AddrOut )
  );
  Mux_16x1 Mux_16x1_i28 (
    .sel( sel ),
    .in_0( 1'b0 ),
    .in_1( s39 ),
    .in_2( s40 ),
    .in_3( 1'b0 ),
    .in_4( 1'b0 ),
    .in_5( 1'b0 ),
    .in_6( 1'b0 ),
    .in_7( 1'b0 ),
    .in_8( s41 ),
    .in_9( s42 ),
    .in_10( s43 ),
    .in_11( 1'b0 ),
    .in_12( 1'b0 ),
    .in_13( 1'b0 ),
    .in_14( 1'b0 ),
    .in_15( 1'b0 ),
    .out( s18 )
  );
  assign s44 = (aluOp[4] & s13);
  // seed
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i29 (
    .D( DataOut ),
    .C( clk ),
    .en( s49 ),
    .Q( s50 )
  );
  assign s49 = (s52 & ioW);
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i30 (
    .a( s1 ),
    .b( s6 ),
    .c_i( s44 ),
    .s( s26 ),
    .c_o( s39 )
  );
  DIG_Sub #(
    .Bits(16)
  )
  DIG_Sub_i31 (
    .a( s1 ),
    .b( s6 ),
    .c_i( s44 ),
    .s( s27 ),
    .c_o( s40 )
  );
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i32 (
    .a( s10 ),
    .b( AddrOut ),
    .c_i( 1'b0 ),
    .s( s23 )
  );
  assign s113 = ((s110 & ~ Reti) | (inter & interEnable));
  // intEn
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i33 (
    .D( DataOut ),
    .C( clk ),
    .en( s115 ),
    .Q( s116 )
  );
  assign s115 = (s117 & ioW);
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i34 (
    .sel( s122 ),
    .in_0( s119 ),
    .in_1( s121 ),
    .out( s123 )
  );
  assign s118 = (intr & interEnable);
  assign s122 = (interEnable & Reti);
  assign s34[14:0] = s1[15:1];
  assign s34[15] = s44;
  assign s33[0] = s44;
  assign s33[15:1] = s1[14:0];
  assign s130 = (s129 & ioW);
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i35 (
    .D( s131 ),
    .C( clk ),
    .en( s130 ),
    .Q( \Output  )
  );
  assign s133 = (s132 & ioW);
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i36 (
    .D( s134 ),
    .C( clk ),
    .en( s133 ),
    .Q( outputToOutsideEnable )
  );
  timer timer_i37 (
    .dOut( DataOut ),
    .Addr( AddrOut ),
    .ioW( ioW ),
    .ioR( ioR ),
    .C( clk ),
    .InterLock( InterLock ),
    .timerConfigAddr( 16'b1 ),
    .timerTargetAddr( 16'b10 ),
    .timerResetAddr( 16'b11 ),
    .timerReadAddr( 16'b1 ),
    .TimerOut( timer_in ),
    .\timer?nterrupt ( inter )
  );
  assign FlagOut[0] = s13;
  assign FlagOut[1] = s14;
  assign FlagOut[2] = s15;
  assign FlagOut[15:3] = 13'b0;
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i38 (
    .a( AddrOut ),
    .b( 16'b0 ),
    .\= ( s19 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i39 (
    .sel( s49 ),
    .in_0( 16'b0 ),
    .in_1( s50 ),
    .out( s51 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i40 (
    .a( AddrOut ),
    .b( 16'b1001 ),
    .\= ( s52 )
  );
  assign s46 = (clk & s49);
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i41 (
    .a( AddrOut ),
    .b( 16'b110 ),
    .\= ( s117 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i42 (
    .sel( s118 ),
    .in_0( s25 ),
    .in_1( 16'b10 ),
    .out( s119 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i43 (
    .a( AddrOut ),
    .b( 16'b111 ),
    .\= ( s129 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i44 (
    .a( AddrOut ),
    .b( 16'b1000 ),
    .\= ( s132 )
  );
  assign s126[0] = 1'b0;
  assign s126[15:1] = AddrOut[14:0];
  assign s20 = AddrOut[15];
  assign interEnable = s116[0];
  assign s136 = AddrOut[15];
  assign s55 = s51[0];
  assign s58 = s51[1];
  assign s60 = s51[2];
  assign s62 = s51[3];
  assign s64 = s51[4];
  assign s66 = s51[5];
  assign s68 = s51[6];
  assign s70 = s51[7];
  assign s72 = s51[8];
  assign s74 = s51[9];
  assign s76 = s51[10];
  assign s78 = s51[11];
  assign s80 = s51[12];
  assign s82 = s51[13];
  assign s84 = s51[14];
  assign s86 = s51[15];
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i45 (
    .Set( 1'b0 ),
    .D( s45 ),
    .C( s46 ),
    .Clr( s47 ),
    .Q( s48 ),
    .\~Q ( s45 )
  );
  assign s54 = (s49 & ~ s53);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i46 (
    .Set( s55 ),
    .D( s56 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s57 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i47 (
    .Set( s58 ),
    .D( s57 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s59 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i48 (
    .Set( s60 ),
    .D( s59 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s61 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i49 (
    .Set( s62 ),
    .D( s61 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s63 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i50 (
    .Set( s64 ),
    .D( s63 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s65 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i51 (
    .Set( s66 ),
    .D( s65 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s67 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i52 (
    .Set( s68 ),
    .D( s67 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s69 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i53 (
    .Set( s70 ),
    .D( s69 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s71 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i54 (
    .Set( s72 ),
    .D( s71 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s73 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i55 (
    .Set( s74 ),
    .D( s73 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s75 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i56 (
    .Set( s76 ),
    .D( s75 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s77 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i57 (
    .Set( s78 ),
    .D( s77 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s79 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i58 (
    .Set( s80 ),
    .D( s79 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s81 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i59 (
    .Set( s82 ),
    .D( s81 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s83 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i60 (
    .Set( s84 ),
    .D( s83 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s85 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i61 (
    .Set( s86 ),
    .D( s85 ),
    .C( clk ),
    .Clr( s54 ),
    .Q( s87 )
  );
  assign s56 = (s67 ^ (s77 ^ (s81 ^ s85)));
  assign RandomNUM[0] = s57;
  assign RandomNUM[1] = s59;
  assign RandomNUM[2] = s61;
  assign RandomNUM[3] = s63;
  assign RandomNUM[4] = s65;
  assign RandomNUM[5] = s67;
  assign RandomNUM[6] = s69;
  assign RandomNUM[7] = s71;
  assign RandomNUM[8] = s73;
  assign RandomNUM[9] = s75;
  assign RandomNUM[10] = s77;
  assign RandomNUM[11] = s79;
  assign RandomNUM[12] = s81;
  assign RandomNUM[13] = s83;
  assign RandomNUM[14] = s85;
  assign RandomNUM[15] = s87;
  assign s53 = (s48 | s47);
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i62 (
    .J( s53 ),
    .C( clk ),
    .K( s53 ),
    .Q( s47 )
  );
  assign PCOut = PCOut_temp;
endmodule
